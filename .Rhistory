<<<<<<< HEAD
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
select(Momemtum) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
select(Momentum) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes non différenciées
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog_train)
# 3. Prédictions in-sample pour l'ensemble d'entraînement
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
# 4. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 5. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV, CPIH_YTYPCT et UNR_us:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,  # Pas besoin d'exclure la première ligne ici
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV, CPIH_YTYPCT et UNR_us",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Préparer les variables exogènes avec les séries non différenciées pour l'ensemble de test
exog_test <- test_data %>%
select(Momentum) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 3. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# 4. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Créer une copie de train_data pour effectuer la différenciation
train_data_diff <- train_data %>%
mutate(
GDPV_diff = c(NA, diff(GDPV)),  # Différenciation de GDPV
CPIH_YTYPCT_diff = c(NA, diff(CPIH_YTYPCT)),  # Différenciation de CPIH_YTYPCT
UNR_us_diff = c(NA, diff(UNR_us))  # Différenciation de UNR_us
)  # Différenciation des variables I(1)
# 2. Préparer les variables exogènes avec les trois variables différenciées
exog_train <- train_data_diff %>%
select(GDPV_diff) %>%
na.omit()  # Supprimer les lignes avec NA (première ligne après différenciation)
# 3. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes modifiées
arimax_model <- arima(train_data$Adj.Close[2:nrow(train_data)], order = c(4, 1, 5), xreg = exog_train)
# 4. Prédictions in-sample (ensemble d'entraînement)
fitted_arimax <- train_data$Adj.Close[2:nrow(train_data)] - residuals(arimax_model)
# 5. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 6. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV_diff, CPIH_YTYPCT_diff et UNR_us_diff:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 7. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date[2:nrow(train_data)],
Observed = train_data$Adj.Close[2:nrow(train_data)],
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV_diff, CPIH_YTYPCT_diff et UNR_us_diff",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Créer une copie de test_data pour effectuer la différenciation
test_data_diff <- test_data %>%
mutate(
GDPV_diff = c(NA, diff(GDPV)),  # Différenciation de GDPV
CPIH_YTYPCT_diff = c(NA, diff(CPIH_YTYPCT)),  # Différenciation de CPIH_YTYPCT
UNR_us_diff = c(NA, diff(UNR_us))  # Différenciation de UNR_us
)
# 2. Préparer les variables exogènes avec les trois variables différenciées pour l'ensemble de test
exog_test <- test_data_diff %>%
select(GDPV_diff) %>%
na.omit()  # Supprimer les lignes avec NA (première ligne après différenciation)
# 3. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 4. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date[2:nrow(test_data)],
Observed = test_data$Adj.Close[2:nrow(test_data)],
Predicted = predictions_test
)
# 5. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 6. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 7. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 8. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
select(CCI) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes non différenciées
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog_train)
# 3. Prédictions in-sample pour l'ensemble d'entraînement
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
# 4. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 5. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV, CPIH_YTYPCT et UNR_us:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,  # Pas besoin d'exclure la première ligne ici
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV, CPIH_YTYPCT et UNR_us",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Préparer les variables exogènes avec les séries non différenciées pour l'ensemble de test
exog_test <- test_data %>%
select(CCI) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 3. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# 4. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
select(Stochastic_K) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes non différenciées
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog_train)
# 3. Prédictions in-sample pour l'ensemble d'entraînement
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
# 4. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 5. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV, CPIH_YTYPCT et UNR_us:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,  # Pas besoin d'exclure la première ligne ici
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV, CPIH_YTYPCT et UNR_us",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Préparer les variables exogènes avec les séries non différenciées pour l'ensemble de test
exog_test <- test_data %>%
select(Stochastic_K) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 3. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# 4. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
select(Stochastic_D) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes non différenciées
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog_train)
# 3. Prédictions in-sample pour l'ensemble d'entraînement
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
# 4. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 5. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV, CPIH_YTYPCT et UNR_us:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,  # Pas besoin d'exclure la première ligne ici
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV, CPIH_YTYPCT et UNR_us",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Préparer les variables exogènes avec les séries non différenciées pour l'ensemble de test
exog_test <- test_data %>%
select(Stochastic_D) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 3. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# 4. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
select(Return) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes non différenciées
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog_train)
# 3. Prédictions in-sample pour l'ensemble d'entraînement
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
# 4. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 5. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV, CPIH_YTYPCT et UNR_us:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,  # Pas besoin d'exclure la première ligne ici
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV, CPIH_YTYPCT et UNR_us",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Préparer les variables exogènes avec les séries non différenciées pour l'ensemble de test
exog_test <- test_data %>%
select(Return) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 3. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# 4. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
select(Close_minus_Open) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes non différenciées
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog_train)
# 3. Prédictions in-sample pour l'ensemble d'entraînement
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
# 4. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 5. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV, CPIH_YTYPCT et UNR_us:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,  # Pas besoin d'exclure la première ligne ici
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV, CPIH_YTYPCT et UNR_us",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Préparer les variables exogènes avec les séries non différenciées pour l'ensemble de test
exog_test <- test_data %>%
select(Close_minus_Open) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 3. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# 4. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
select(Stochastic_K) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes non différenciées
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog_train)
# 3. Prédictions in-sample pour l'ensemble d'entraînement
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
# 4. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 5. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV, CPIH_YTYPCT et UNR_us:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,  # Pas besoin d'exclure la première ligne ici
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV, CPIH_YTYPCT et UNR_us",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Préparer les variables exogènes avec les séries non différenciées pour l'ensemble de test
exog_test <- test_data %>%
select(Stochastic_K) %>%
na.omit()  # Supprimer les lignes avec NA (si nécessaire)
# 2. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 3. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# 4. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
=======
setwd("~/Ensai/3A/Series_temp/Project/projet_STA")
# Load libraries
library(rugarch)
library(dplyr)
library(tseries)
# Load data
data <- read.csv("data/output/final_database.csv")
data$Date <- as.Date(data$Date, format = "%Y-%m-%d")
########## GARCH MODEL
# Volatility clusters in time series data
plot.ts(data$Return)
# Autocorrelation of the return
acf(data$Return)
# Autocorrelation of the squared return
acf(data$Return**2)
# Load libraries
library(rugarch)
library(dplyr)
library(tseries)
# Load data
data <- read.csv("data/output/final_database.csv")
data$Date <- as.Date(data$Date, format = "%Y-%m-%d")
########## GARCH MODEL
# Volatility clusters in time series data
plot.ts(data$Return)
## Estimation of order of GARCH model
acf(data$Return**2 - mean(data$Return**2))
data_train <- data[data$Date < "2023-01-01",]
data_test <- data[data$Date >= "2023-01-01",]
# Use of ARMA representation of e^2
find_garch <- function(p_min,p_max,q_min,q_max, data, dist="norm"){
best_aic <- Inf
best_order <- c(0, 0, 0)
results <- data.frame(p = integer(),
q = integer(),
aic = numeric(),
relative_gap = numeric(),
stringsAsFactors = FALSE)
for (p in p_min:p_max) {
for (q in q_min:q_max) {
garch_spec <- ugarchspec( variance.model = list(model ="sGARCH", garchOrder = c(p, q)),
mean.model = list(armaOrder = c(0, 0)),
distribution.model =dist)
out <-  ugarchfit(spec =garch_spec, data = data)
current_aic <- infocriteria(out)[1]*length(data)
if (current_aic < best_aic) {
best_aic <- current_aic
best_order <- c(p, 0, q)
}
results <- rbind(results, data.frame(p = p,
q = q,
aic = current_aic,
relative_gap = NA))
#}
}
}
results$relative_gap <- (results$aic - best_aic)*100 / best_aic
return(results)
}
# Find the best GARCH model
p_min <- 0
p_max <- 1
q_min <- 1
q_max <- 2
results<- find_garch(p_min, p_max, q_min, q_max, data_train$Return**2,dist="norm")
# latex table
print(xtable::xtable(results, type = "latex"))
# Fonction pour ajuster un modèle GARCH avec une distribution spécifiée
fit_garch <- function(data, n_test, distribution = "norm", model ="sGARCH",submodel=NULL, garch_order = c(1, 1), arma_order = c(0, 0)) {
# Spécification du modèle GARCH
garch_spec <- ugarchspec(
variance.model = list(model = model, garchOrder = garch_order, submodel=submodel),
mean.model = list(armaOrder = arma_order),
distribution.model = distribution
)
# Ajustement du modèle GARCH
garch_fit <- ugarchfit(spec = garch_spec, data = data, out.sample = n_test)
# Fitted values
fitted <- list()
fitted$sigma <-garch_fit@fit$sigma
fitted$mean <- garch_fit@fit$fitted
return(list(garch_fit = garch_fit, fitted = fitted))
}
# Fonction pour générer des prévisions avec un modèle GARCH ajusté
forecast_garch <- function(garch_fit, data, n_test, n_ahead = 1) {
garch_forecast <- ugarchforecast(garch_fit, data = data, n.ahead = n_ahead, n.roll = n_test - 1)
forecast <- list()
forecast$sigma <- as.numeric(garch_forecast@forecast$sigmaFor)
forecast$mean <- as.numeric(garch_forecast@forecast$seriesFor)
return(forecast)
}
# Compute performance
performance <- function(predicted, realized){
N <- length(realized)
# Root Mean Squared Error (RMSE)
rmse <- sum((predicted - realized)**2) / N
# Mean Absolute Error (MAE)
mae <- (1 / N) * sum(abs(predicted - realized))
# Heteroscedasticity-adjusted MAE (HMAE)
hmae <- (1 / N) * sum(abs( 1 - predicted / realized))
return(list(rmse = rmse, mae = mae, hmae = hmae))
}
# Fonction pour effectuer le workflow complet
run_garch <- function(data,n_test, distribution = "norm",model ="sGARCH",submodel= NULL, garch_order = c(1, 1), arma_order = c(0, 0)) {
N <- length(data)
data_train <- data[1:(N - n_test)]
data_test <- data[(N- n_test + 1):N]
# Ajustement du modèle
fit_results <- fit_garch(data,n_test,distribution,model, submodel, garch_order, arma_order)
garch_fit <- fit_results$garch_fit
# Prévisions
forecast <- forecast_garch(garch_fit, data,n_test, n_ahead = 1)
# Proxy de volatilité
# # Lorsqu’on ne dispose pas de données intrajournalières pour calculer des proxies comme la Realized Volatility
# # ou la Realized High-Low Volatility, le deuxième meilleur proxy de la variance est généralement le carré du rendement.
vol_proxy_test <- sqrt(data_test^2)
vol_proxy_train <- sqrt(data_train^2)
# Performance
perf_train <- performance(sigma(garch_fit), vol_proxy_train)
perf_test <- performance(forecast$sigma, vol_proxy_test)
return(list(fit = garch_fit, fitted = fit_results$fitted, forecast = forecast, performance_train = perf_train, performance_test = perf_test, vol_proxy_test = vol_proxy_test, vol_proxy_train=vol_proxy_train))
}
n_test <- nrow(data_test)
res_norm<- run_garch(data$Return, n_test, distribution = "norm",model ="sGARCH", submodel=NULL, garch_order = c(1, 1), arma_order = c(0, 0))
res_norm$fit
# Jacques bera test for normality
jarque.bera.test(res_norm$fit@fit$residuals)
# Example: list of performance metrics
performance_results <- list(
res_norm$performance_test,
res_std$performance_test,
res_sstd$performance_test,
res_ged$performance_test,
res_sged$performance_test
)
# Convert list to a dataframe
performance_df <- bind_rows(performance_results, .id = "Model") %>%
mutate(Model = c("Norm", "Std", "Sstd", "Ged", "Sged"))
# View the structured dataframe
print(performance_df)
# Example: list of performance metrics
performance_results <- list(
res_norm$performance_test,
res_std$performance_test,
res_sstd$performance_test,
res_ged$performance_test,
res_sged$performance_test
)
n_test <- nrow(data_test)
res_norm<- run_garch(data$Return, n_test, distribution = "norm",model ="sGARCH", submodel=NULL, garch_order = c(1, 1), arma_order = c(0, 0))
res_norm$fit
#### Regarder le paramètre de forme pour indication sur les lois à tester
# Jacques bera test for normality
jarque.bera.test(res_norm$fit@fit$residuals)
# Print performance
#res_norm$performance_train
res_norm$performance_test
info <- infocriteria(res_norm$fit)
# Extract AIC and BIC
info[1]
info[2]
########## GARCH(1,1) model with Student distribution
res_std<- run_garch(data$Return, n_test, distribution = "std",model ="sGARCH", submodel=NULL, garch_order = c(1, 1), arma_order = c(0, 0))
# Print performance
res_std$performance_test
########## GARCH(1,1) model with skew student distribution
res_sstd<- run_garch(data$Return, n_test, distribution = "sstd", model ="sGARCH", submodel=NULL, garch_order = c(1, 1), arma_order = c(0, 0))
# Print performance
res_sstd$performance_test
########## GARCH(1,1) model with generalized error distribution
res_ged<- run_garch(data$Return, n_test, distribution = "ged",model ="sGARCH", submodel=NULL, garch_order = c(1, 1), arma_order = c(0, 0))
# Print performance
res_ged$performance_test
########## GARCH(1,1) model with skewed generalized error distribution
res_sged<- run_garch(data$Return, n_test, distribution = "sged",model ="sGARCH", submodel=NULL, garch_order = c(1, 1), arma_order = c(0, 0))
# Print performance
res_sged$performance_test
# Example: list of performance metrics
performance_results <- list(
res_norm$performance_test,
res_std$performance_test,
res_sstd$performance_test,
res_ged$performance_test,
res_sged$performance_test
)
# Convert list to a dataframe
performance_df <- bind_rows(performance_results, .id = "Model") %>%
mutate(Model = c("Norm", "Std", "Sstd", "Ged", "Sged"))
# View the structured dataframe
print(performance_df)
#### Plot results of best model
res_sstd$forecast$date <- data_test$Date
res_sstd$fitted$date <- data_train$Date
plot(data_train$Date, data_train$Return, type = "l", col = "black", xlab = "Date", ylab = "Return")
lines(res_sstd$fitted$date, res_sstd$fitted$sigma, col = "red")
lines(data_test$Date, data_test$Return, type = "l", col = "blue", xlab = "Date", ylab = "Return", main = "GARCH(1,1) Forecast")
lines(res_sstd$forecast$date, res_sstd$forecast$sigma, type = "l", col = "red", xlab = "Date", ylab = "Volatility", main = "GARCH(1,1) Forecast")
legend("bottomleft", legend = c("Train","Test", "Volatility predicted"), col = c("black","blue", "red"), lty = 1:1, cex = 0.8)
########## eGARCH(1,1) model with skew student distribution
res_sstd_egarch<- run_garch(data$Return, n_test, distribution = "sstd" ,model ="eGARCH", submodel=NULL, garch_order = c(1, 1), arma_order = c(0, 0))
# Print performance
res_sstd_egarch$performance_test
########## TGARCH(1,1) model with skew student distribution
res_sstd_tgarch<- run_garch(data$Return, n_test, distribution = "sstd" ,model ="fGARCH",submodel="TGARCH", garch_order = c(1, 1), arma_order = c(0, 0))
# Print performance
res_sstd_tgarch$performance_test
## add to performance df
performance_results <- list(
res_norm$performance_test,
res_std$performance_test,
res_sstd$performance_test,
res_ged$performance_test,
res_sged$performance_test,
res_sstd_egarch$performance_test,
res_sstd_tgarch$performance_test
)
# Convert list to a dataframe
performance_df <- bind_rows(performance_results, .id = "Model") %>%
mutate(Model = c("Norm", "Std", "Sstd", "Ged", "Sged", "Sstd_egarch", "Sstd_tgarch"))
performance_df
>>>>>>> 7866dff01e8ccdffcb33edb831d27d6f3e10ef36
