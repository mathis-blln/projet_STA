# Afficher les résultats du test
print(adf_test)
# Test KPSS sur les rendements logarithmiques
kpss_test <- ur.kpss(na.omit(log_returns))
# Résumé des résultats
summary(kpss_test)
library(readr)
library(ggplot2)  # Pour créer les graphiques
library(zoo)  # Pour gérer les périodes trimestrielles
# pour les données de la france
library(dplyr)  # Pour manipuler les données
library(tidyr)
eco_data <- read_csv("OECD.ECO.MAD,DSD_EO@DF_EO,1.2+FRA.UNR+CPIH_YTYPCT+IRL+IRS+YPH+GDP+GDPV+IRCB.Q.csv",
show_col_types = FALSE)
colnames(eco_data)
eco_data$TIME_PERIOD <- as.yearqtr(eco_data$TIME_PERIOD, format="%Y-Q%q")
eco_data_wide <- eco_data %>%
dplyr::select(TIME_PERIOD, MEASURE, OBS_VALUE) %>%
tidyr::pivot_wider(
names_from = MEASURE,   # Les variables (comme GDP, GNP) deviendront des colonnes
values_from = OBS_VALUE # Les valeurs associées aux variables
) %>%
arrange(TIME_PERIOD)
# Liste des variables (exclure TIME_PERIOD)
variables <- colnames(eco_data_wide)[-1]
# Créer un graphique pour chaque variable, un par un
for (var in variables) {
print(
ggplot(eco_data_wide, aes_string(x = "TIME_PERIOD", y = var)) +
geom_point(color = "blue") +
labs(title = paste("Nuage de points pour", var),
x = "Temps (Trimestres)",
y = var) +
theme_minimal()
)
}
#pour les US
eco_data_us <- read_csv("OECD.ECO.MAD,DSD_EO@DF_EO,1.2+USA.CPI+UNR+IRCB.Q.csv",
show_col_types = FALSE)
eco_data_us$TIME_PERIOD <- as.yearqtr(eco_data_us$TIME_PERIOD, format="%Y-Q%q")
eco_data_wide_us <- eco_data_us %>%
dplyr::select(TIME_PERIOD, MEASURE, OBS_VALUE) %>%
tidyr::pivot_wider(
names_from = MEASURE,   # Les variables comme GDP, GNP deviendront des colonnes
values_from = OBS_VALUE # Les valeurs associées aux variables
) %>%
dplyr::arrange(TIME_PERIOD)
colnames(eco_data_wide_us) <- ifelse(colnames(eco_data_wide_us) != "TIME_PERIOD",
paste0(colnames(eco_data_wide_us), "_us"),
colnames(eco_data_wide_us))
# Fusionner les deux dataframes sur TIME_PERIOD (en utilisant une jointure gauche pour garder toutes les lignes de eco_data_wide)
eco_data_combined <- merge(eco_data_wide, eco_data_wide_us, by = "TIME_PERIOD", all.x = TRUE)
library(dplyr)
library(tidyr)
library(zoo)
eco_data_combined$TIME_PERIOD <- as.yearqtr(eco_data_combined$TIME_PERIOD, format="%Y-Q%q")
# Convertir les trimestres en dates, par exemple en prenant le 1er jour de chaque trimestre
eco_data_combined$DATE <- as.Date(eco_data_combined$TIME_PERIOD)
# Créer une séquence de dates journalières entre la première et la dernière date
date_seq <- seq(from = min(eco_data_combined$DATE), to = max(eco_data_combined$DATE), by = "day")
# Fonction d'interpolation pour chaque colonne
interpolate_column <- function(column_values, date_seq, eco_data) {
approx_dates <- as.numeric(eco_data$DATE)  # Convertir les dates en numéros pour interpolation
approx_values <- column_values
approx_result <- approx(approx_dates, approx_values, xout = as.numeric(date_seq), method = "linear")$y
return(approx_result)
}
# Créer un dataframe vide pour les dates journalières
eco_data_daily <- data.frame(DATE = date_seq)
# Appliquer l'interpolation sur toutes les colonnes sauf TIME_PERIOD et DATE
for (col in colnames(eco_data_combined)[-c(1, ncol(eco_data_combined))]) {
eco_data_daily[[col]] <- interpolate_column(eco_data_combined[[col]], date_seq, eco_data_combined)
}
# Afficher les premières lignes du dataframe avec les données journalières interpolées
head(eco_data_daily)
eco_data_after_date <- eco_data_daily %>%
filter(DATE > as.Date("2024-10-30"))
# Sauvegarder dans un fichier CSV
write.csv(eco_data_after_date, "eco_data_after_2024-10-30.csv", row.names = FALSE)
cac40_close_df <- data.frame(Date = index(cac40_close), Value = coredata(cac40_close))
colnames(cac40_close_df) <- c("DATE", "CAC40")
# Joindre les valeurs de CAC 40 dans eco_data_daily selon la colonne DATE
eco_data_daily <- left_join(eco_data_daily, cac40_close_df, by = "DATE")
colnames(eco_data_daily)
eco_data_daily_clean <- eco_data_daily[!is.na(eco_data_daily$CAC40), ]
write.csv(eco_data_daily_clean, "eco_data_daily_clean.csv", row.names = FALSE)
final_database <- read_csv("final_database.csv", show_col_types = FALSE)
final_database$Date <- as.Date(final_database$Date)
# Convertir toutes les autres colonnes en numérique
numeric_columns <- setdiff(names(final_database), "Date")  # Sélectionner toutes les colonnes sauf 'Date'
final_database[numeric_columns] <- lapply(final_database[numeric_columns], as.numeric)
# Check for missing values
missing_values <- sum(is.na(final_database$Adj.Close))
# Display the number of missing values
print(paste("Number of missing values:", missing_values))
# If missing values exist, display their dates
if (missing_values > 0) {
missing_dates <- final_database$Date[is.na(final_database$Adj.Close)]
print("Dates with missing values:")
print(missing_dates)
} else {
print("No missing values in the series.")
}
# Descriptive statistics
basicStats(final_database$Adj.Close)
# Add a linear trend
ggplot(final_database, aes(x = Date, y = Adj.Close)) +
geom_line(color = "black") +
geom_smooth(method = "lm", se = FALSE, color = "red") +
ggtitle("Linear Trend of the Index") +
xlab("Date") +
ylab("Closing Price") +
theme_minimal()
# Fit a linear model: Price ~ Time
time <- as.numeric(final_database$Date) # Convert dates to numeric values
lm_model <- lm(final_database$Adj.Close ~ time)
# Model summary
summary(lm_model)
# Convert the series to monthly frequency
final_xts <- xts(final_database$Adj.Close, order.by = final_database$Date)
final_monthly <- to.monthly(final_xts, indexAt = "lastof", OHLC = FALSE)
# Visualize monthly averages
final_monthly_mean <- aggregate(final_monthly, as.yearmon, mean)
autoplot(final_monthly_mean) +
ggtitle("Monthly Averages of the Index") +
xlab("Date") +
ylab("Monthly Closing Average") +
theme_minimal()
# Séparer les données en train (avant janvier 2023) et test (après janvier 2023)
train_data <- final_database %>% filter(Date < "2023-01-01")
test_data <- final_database %>% filter(Date >= "2023-01-01")
# Calculer les log-returns pour l'ensemble train
log_returns_train <- diff(log(train_data$Adj.Close))
log_returns_train <- na.omit(log_returns_train)
acf(train_data$Adj.Close)
pacf(train_data$Adj.Close)
acf(log_returns_train)
pacf(log_returns_train)
# Définir les paramètres pour les modèles ARMA
p_values <- 1:6  # Valeurs de p
q_values <- 1:6  # Valeurs de q
# Stocker les modèles et leurs résultats
models <- list()
valid_models <- list()
aic_values <- c()
bic_values <- c()
box_test_results <- list()
# Ajustement des modèles ARMA et vérification de la blancheur des résidus sur l'ensemble train
for (p in p_values) {
for (q in q_values) {
model_name <- paste0("ARIMA", p, q)
# Ajuster le modèle ARMA(p, q) sur les log_returns_train
models[[model_name]] <- arima(train_data$Adj.Close, order = c(p, 1, q))
# Récupérer les résidus et effectuer le test de Ljung-Box
resid <- residuals(models[[model_name]])
box_test <- Box.test(resid, lag = 30)
# Stocker le résultat du test
box_test_results[[model_name]] <- box_test
# Si les résidus sont blancs (p-value > 0.05), ajouter à la liste des modèles valides
if (box_test$p.value > 0.05) {
valid_models[[model_name]] <- models[[model_name]]
aic_values[model_name] <- AIC(models[[model_name]])
bic_values[model_name] <- BIC(models[[model_name]])
}
}
}
# Afficher les résultats des tests de blancheur
cat("Résultats des tests de blancheur des résidus (p-value) :\n")
for (model_name in names(box_test_results)) {
cat(model_name, ": p-value =", box_test_results[[model_name]]$p.value, "\n")
}
# Évaluer les modèles valides uniquement
if (length(valid_models) > 0) {
cat("\nCritères AIC et BIC pour les modèles valides :\n")
aic_results <- data.frame(Model = names(aic_values), AIC = aic_values, BIC = bic_values)
print(aic_results[order(aic_results$AIC), ])  # Trier par AIC
# Identifier le meilleur modèle parmi les modèles valides
best_model <- names(which.min(aic_values))
cat("\nMeilleur modèle basé sur AIC parmi les modèles valides :", best_model, "\n")
} else {
cat("\nAucun modèle n'a passé le test de blancheur des résidus.\n")
}
library(ggplot2)
library(dplyr)
# Ajuster le modèle ARIMA(5,1,4) sur l'ensemble d'entraînement
best_arma_model <- arima(train_data$Adj.Close, order = c(5, 1, 4))
# Résumé du modèle ARIMA
summary(best_arma_model)
# Faire des prédictions pour l'ensemble d'entraînement (valeurs ajustées)
fitted_train <- train_data$Adj.Close - residuals(best_arma_model)
# Créer un data frame pour les vraies valeurs et les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,
Observed = train_data$Adj.Close,
Predicted = fitted_train
)
# Calculer les erreurs sur l'ensemble d'entraînement
errors_train <- plot_data_train$Observed - plot_data_train$Predicted
rmse_train <- sqrt(mean(errors_train^2))
mae_train <- mean(abs(errors_train))
# Afficher les résultats pour l'ensemble d'entraînement
cat("Performance du modèle ARIMA(5,1,4) pour l'ensemble d'entraînement :\n")
cat("RMSE : ", rmse_train, "\n")
cat("MAE : ", mae_train, "\n")
# Ajouter une colonne pour les années et découper par tranches de 5 ans
plot_data_train <- plot_data_train %>%
mutate(
Year = as.numeric(format(Time, "%Y")),
Period = paste0(floor(Year / 5) * 5, "-", floor(Year / 5) * 5 + 4)  # Tranches de 5 ans
)
# Découper les données en tranches de 5 ans
periods <- unique(plot_data_train$Period)
# Générer un graphique pour chaque tranche de 5 ans
for (period in periods) {
# Filtrer les données pour la tranche actuelle
period_data <- filter(plot_data_train, Period == period)
# Générer un graphique pour la tranche actuelle
p <- ggplot(period_data, aes(x = Time)) +
geom_line(aes(y = Observed), color = 'black', linewidth = 1) +  # Série observée en noir
geom_line(aes(y = Predicted), color = 'blue', linewidth = 1) +  # Prédictions en bleu
labs(
title = paste("Comparaison des prédictions ARIMA(5,1,4) - Période :", period),
x = "Date", y = "Valeur Ajustée"
) +
theme_minimal()
# Afficher le graphique
print(p)
}
# Faire des prédictions sur l'ensemble de test (n.ahead = longueur de test_data)
predictions_test <- predict(best_arma_model, n.ahead = length(test_data$Adj.Close))$pred
# Créer un data frame pour les valeurs observées et les prédictions de test
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# Tracer les vraies valeurs et les prédictions pour l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed"), size = 1) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed", size = 1) +
labs(title = "Prédictions vs Valeurs Réelles - Test", x = "Date", y = "Valeur Ajustée") +
scale_color_manual(values = c("Observed" = "blue", "Predicted" = "red")) +
theme_minimal()
# Calculer les erreurs sur l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMA(5,1,4) pour l'ensemble de test :\n")
cat("RMSE : ", rmse_test, "\n")
cat("MAE : ", mae_test, "\n")
exog <- train_data %>%
select(Momentum, Stochastic_K, CCI)
exog <- train_data %>%
select(Momentum, Stochastic_K, CCI)
library(dplyr)
exog <- train_data %>%
select(Momentum, Stochastic_K, CCI)
View(train_data)
library(dplyr)
library(tidyr)
exog <- train_data %>%
select(Momentum, Stochastic_K, CCI)
library(dplyr)
library(tidyr)
exog <- dplyr::select(train_data, Momentum, Stochastic_K, CCI)
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog)
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
cat("Performance ARIMAX(4,1,5) avec GDP:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data <- data.frame(
Time = train_data$Date,
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# Préparer les données exogènes pour l'ensemble de test
exog_test <- test_data %>%
select(Momentum, Stochastic_K, CCI)
# Préparer les données exogènes pour l'ensemble de test
exog_test <- dplyr::select(test_data, Momentum, Stochastic_K, CCI)
# Faire des prédictions sur l'ensemble test
predictions_test <- predict(arimax_model, n.ahead = nrow(test_data), newxreg = exog_test)
# Extraire les prédictions
predicted_test <- predictions_test$pred
# Créer un data frame avec les vraies valeurs et les prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predicted_test
)
# Calculer les erreurs
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# Afficher les résultats
cat("Performance ARIMAX(4,1,5) sur l'ensemble test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# Visualiser les résultats
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX vs Observations - Ensemble Test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 1. Créer une copie de train_data pour effectuer la différenciation
train_data_diff <- train_data %>%
mutate(
GDPV_diff = c(NA, diff(GDPV)),  # Différenciation de GDPV
CPIH_YTYPCT_diff = c(NA, diff(CPIH_YTYPCT)),  # Différenciation de CPIH_YTYPCT
UNR_us_diff = c(NA, diff(UNR_us))  # Différenciation de UNR_us
)  # Différenciation des variables I(1)
# 2. Préparer les variables exogènes avec les trois variables différenciées
exog_train <- train_data_diff %>%
select(GDPV_diff) %>%
na.omit()  # Supprimer les lignes avec NA (première ligne après différenciation)
# 1. Créer une copie de train_data pour effectuer la différenciation
train_data_diff <- train_data %>%
mutate(
GDPV_diff = c(NA, diff(GDPV)),  # Différenciation de GDPV
CPIH_YTYPCT_diff = c(NA, diff(CPIH_YTYPCT)),  # Différenciation de CPIH_YTYPCT
UNR_us_diff = c(NA, diff(UNR_us))  # Différenciation de UNR_us
)  # Différenciation des variables I(1)
# 2. Préparer les variables exogènes avec les trois variables différenciées
exog_train <- train_data_diff %>%
dplyr::select(GDPV_diff) %>%  # Sélectionner uniquement la colonne GDPV_diff
dplyr::filter(!is.na(GDPV_diff))  # Supprimer les lignes où GDPV_diff est NA
# 3. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes modifiées
arimax_model <- arima(train_data$Adj.Close[2:nrow(train_data)], order = c(4, 1, 5), xreg = exog_train)
# 4. Prédictions in-sample (ensemble d'entraînement)
fitted_arimax <- train_data$Adj.Close[2:nrow(train_data)] - residuals(arimax_model)
# 5. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 6. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV_diff, CPIH_YTYPCT_diff et UNR_us_diff:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 7. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date[2:nrow(train_data)],
Observed = train_data$Adj.Close[2:nrow(train_data)],
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV_diff, CPIH_YTYPCT_diff et UNR_us_diff",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Créer une copie de test_data pour effectuer la différenciation
test_data_diff <- test_data %>%
mutate(
GDPV_diff = c(NA, diff(GDPV)),  # Différenciation de GDPV
CPIH_YTYPCT_diff = c(NA, diff(CPIH_YTYPCT)),  # Différenciation de CPIH_YTYPCT
UNR_us_diff = c(NA, diff(UNR_us))  # Différenciation de UNR_us
)
# 2. Préparer les variables exogènes avec les trois variables différenciées pour l'ensemble de test
exog_test <- test_data_diff %>%
select(GDPV_diff) %>%
na.omit()  # Supprimer les lignes avec NA (première ligne après différenciation)
# 1. Créer une copie de train_data pour effectuer la différenciation
train_data_diff <- train_data %>%
mutate(
GDPV_diff = c(NA, diff(GDPV)),  # Différenciation de GDPV
CPIH_YTYPCT_diff = c(NA, diff(CPIH_YTYPCT)),  # Différenciation de CPIH_YTYPCT
UNR_us_diff = c(NA, diff(UNR_us))  # Différenciation de UNR_us
)  # Différenciation des variables I(1)
# 2. Préparer les variables exogènes avec les trois variables différenciées
exog_train <- train_data_diff %>%
dplyr::select(GDPV_diff) %>%  # Sélectionner uniquement la colonne GDPV_diff
dplyr::filter(!is.na(GDPV_diff))  # Supprimer les lignes où GDPV_diff est NA
# 3. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes modifiées
arimax_model <- arima(train_data$Adj.Close[2:nrow(train_data)], order = c(4, 1, 5), xreg = exog_train)
# 4. Prédictions in-sample (ensemble d'entraînement)
fitted_arimax <- train_data$Adj.Close[2:nrow(train_data)] - residuals(arimax_model)
# 5. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 6. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV_diff, CPIH_YTYPCT_diff et UNR_us_diff:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 7. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date[2:nrow(train_data)],
Observed = train_data$Adj.Close[2:nrow(train_data)],
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV_diff, CPIH_YTYPCT_diff et UNR_us_diff",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Créer une copie de test_data pour effectuer la différenciation
test_data_diff <- test_data %>%
mutate(
GDPV_diff = c(NA, diff(GDPV)),  # Différenciation de GDPV
CPIH_YTYPCT_diff = c(NA, diff(CPIH_YTYPCT)),  # Différenciation de CPIH_YTYPCT
UNR_us_diff = c(NA, diff(UNR_us))  # Différenciation de UNR_us
)
# 2. Préparer les variables exogènes avec les trois variables différenciées pour l'ensemble de test
exog_test <- test_data_diff %>%
dplyr::select(GDPV_diff) %>%  # Sélectionner uniquement la colonne GDPV_diff
dplyr::filter(!is.na(GDPV_diff))  # Supprimer les lignes où GDPV_diff est NA
# 3. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 4. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date[2:nrow(test_data)],
Observed = test_data$Adj.Close[2:nrow(test_data)],
Predicted = predictions_test
)
# 5. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 6. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 7. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 8. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
# 1. Préparer les variables exogènes avec les séries non différenciées
exog_train <- train_data %>%
dplyr::select(Stochastic_K) %>%  # Sélectionner uniquement la colonne Stochastic_K
dplyr::filter(!is.na(Stochastic_K))  # Supprimer les lignes où Stochastic_K est NA
# 2. Ajuster le modèle ARIMAX sur train_data en utilisant les variables exogènes non différenciées
arimax_model <- arima(train_data$Adj.Close, order = c(4, 1, 5), xreg = exog_train)
# 3. Prédictions in-sample pour l'ensemble d'entraînement
fitted_arimax <- train_data$Adj.Close - residuals(arimax_model)
# 4. Calcul des métriques pour l'ensemble d'entraînement
rmse_arimax <- sqrt(mean(residuals(arimax_model)^2, na.rm = TRUE))
mae_arimax <- mean(abs(residuals(arimax_model)), na.rm = TRUE)
# 5. Affichage des performances
cat("Performance ARIMAX(4,1,5) avec GDPV, CPIH_YTYPCT et UNR_us:\n")
cat("RMSE :", rmse_arimax, "\n")
cat("MAE :", mae_arimax, "\n")
# 6. Visualiser les prédictions in-sample
plot_data_train <- data.frame(
Time = train_data$Date,  # Pas besoin d'exclure la première ligne ici
Observed = train_data$Adj.Close,
ARIMAX = fitted_arimax
)
ggplot(plot_data_train, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = ARIMAX, color = "ARIMAX"), linetype = "dashed") +
labs(title = "Modèle ARIMAX avec GDPV, CPIH_YTYPCT et UNR_us",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "ARIMAX" = "red")) +
theme_minimal()
# --------------------------------
# Prédictions sur l'ensemble de test
# --------------------------------
# 1. Préparer les variables exogènes avec les séries non différenciées pour l'ensemble de test
exog_test <- test_data %>%
dplyr::select(Stochastic_K) %>%  # Sélectionner uniquement la colonne Stochastic_K
dplyr::filter(!is.na(Stochastic_K))  # Supprimer les lignes où Stochastic_K est NA
# 2. Prédictions sur l'ensemble de test
predictions_test <- predict(arimax_model, n.ahead = nrow(exog_test), newxreg = exog_test)$pred
# 3. Créer le dataframe des prédictions
plot_data_test <- data.frame(
Time = test_data$Date,
Observed = test_data$Adj.Close,
Predicted = predictions_test
)
# 4. Visualisation des prédictions sur l'ensemble de test
ggplot(plot_data_test, aes(x = Time)) +
geom_line(aes(y = Observed, color = "Observed")) +
geom_line(aes(y = Predicted, color = "Predicted"), linetype = "dashed") +
labs(title = "Prédictions ARIMAX sur l'ensemble de test",
x = "Date", y = "Adj.Close") +
scale_color_manual(values = c("Observed" = "black", "Predicted" = "red")) +
theme_minimal()
# 5. Calculer les erreurs pour l'ensemble de test
errors_test <- plot_data_test$Observed - plot_data_test$Predicted
# 6. Calculer RMSE et MAE pour l'ensemble de test
rmse_test <- sqrt(mean(errors_test^2))
mae_test <- mean(abs(errors_test))
# 7. Afficher les résultats pour l'ensemble de test
cat("Performance du modèle ARIMAX sur l'ensemble de test :\n")
cat("RMSE :", rmse_test, "\n")
cat("MAE :", mae_test, "\n")
