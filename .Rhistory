knitr::opts_chunk$set(echo = TRUE)
if (!require("quantmod")) install.packages("quantmod")
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("fBasics")) install.packages("fBasics")
if (!require("tseries")) install.packages("tseries")
if (!require("urca")) install.packages("urca")
library(quantmod)
library(tidyverse)
library(fBasics)
library(tseries)
library(urca)
# Télécharger les données du CAC 40
cac40 <- getSymbols("^FCHI", src = "yahoo", from = "1990-01-01", to = "2023-12-31", auto.assign = FALSE)
# Extraire uniquement les prix de clôture
cac40_close <- na.omit(Cl(cac40))  # 'Cl()' extrait la colonne de clôture
#nous pouvons également considérer d'autres indicateurs tq le max sur la journée, le min...
colnames(cac40_close) <- "Close"
#Visualisation de la série
autoplot(cac40_close) +
ggtitle("Indice CAC 40 pour la période 1990-2023") +
xlab("Date") +
ylab("Clôture") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Vérifier s'il y a des valeurs manquantes dans la série
missing_values <- sum(is.na(cac40_close))
# Afficher le nombre de valeurs manquantes
print(paste("Nombre de valeurs manquantes :", missing_values))
# Si des valeurs manquantes existent, afficher leurs dates
if (missing_values > 0) {
missing_dates <- index(cac40_close)[is.na(cac40_close)]
print("Dates avec valeurs manquantes :")
print(missing_dates)
} else {
print("Aucune valeur manquante dans la série.")
}
basicStats(cac40_close)
#graphiquement
# Ajouter une tendance linéaire
autoplot(cac40_close) +
geom_smooth(method = "lm", se = FALSE, color = "red") +
ggtitle("Tendance linéaire de l'indice CAC 40") +
xlab("Date") +
ylab("Clôture") +
theme_minimal()
#avec le R**2
# Créer une variable temporelle
time <- as.numeric(index(cac40_close))
# Ajuster un modèle linéaire : Prix ~ Temps
lm_model <- lm(coredata(cac40_close) ~ time)
# Résumé du modèle
summary(lm_model)
# Convertir la série en périodicité mensuelle
cac40_monthly <- to.monthly(cac40_close, indexAt = "lastof", OHLC = FALSE)
# Visualisation des moyennes mensuelles
cac40_monthly_mean <- aggregate(cac40_monthly, as.yearmon, mean)
autoplot(cac40_monthly_mean) +
ggtitle("Moyennes mensuelles de l'indice CAC 40") +
xlab("Date") +
ylab("Moyenne mensuelle de clôture") +
theme_minimal()
# Détection visuelle avec boxplot
boxplot(coredata(cac40_close), main = "Détection des outliers",
ylab = "Prix de clôture", col = "lightblue")
# Repérer les outliers par quantile
q1 <- quantile(cac40_close, 0.25)
q3 <- quantile(cac40_close, 0.75)
iqr <- q3 - q1
outliers <- cac40_close[cac40_close < (q1 - 1.5 * iqr) | cac40_close > (q3 + 1.5 * iqr)]
print("Outliers détectés :")
print(outliers)
# Calcul des rendements logarithmiques
log_returns <- diff(log(cac40_close))
# Visualisation des rendements
autoplot(log_returns) +
ggtitle("Rendements logarithmiques du CAC 40") +
xlab("Date") +
ylab("Log-returns") +
theme_minimal()
# Statistiques descriptives des rendements
basicStats(log_returns)
# Histogramme des rendements
ggplot(data = data.frame(log_returns = coredata(log_returns)), aes(x = log_returns)) +
geom_histogram(bins = 50, fill = "lightblue", color = "black") +
ggtitle("Distribution des rendements logarithmiques") +
xlab("Log-returns") +
ylab("Fréquence") +
theme_minimal()
# Calcul des log-returns
log_returns <- diff(log(cac40_close))
# Test ADF sur les rendements logarithmiques
adf_test <- adf.test(na.omit(log_returns))
# Afficher les résultats du test
print(adf_test)
# Calcul des log-returns
log_returns <- diff(log(cac40_close))
# Test KPSS sur les rendements logarithmiques
kpss_test <- ur.kpss(na.omit(log_returns))
# Résumé des résultats
summary(kpss_test)
acf(log_returns)
basicStats(log_returns)
basicStats(log_returns)
log_returns <- na.omit(log_returns)
acf(log_returns)
basicStats(log_returns)
log_returns <- na.omit(log_returns)
acf(log_returns)
pacf(log_returns)
diff_cac<-diff(cac40_close)
diff_cac<-as.vector(diff_cac)
plot.ts(diff_cac)
acf(diff_cac)
diff_cac<-diff(cac40_close)
diff_cac<-as.vector(diff_cac)
plot.ts(diff_cac)
diff_cac <- na.omit(diff_cac)
acf(diff_cac)
pacf(diff_cac)
basicStats(log_returns)
log_returns <- na.omit(log_returns)
acf(log_returns)
pacf(log_returns)
library(tseries)
data(USeconomic)
GNPts<-USeconomic[,2]
plot.ts(GNPts)
# La série est non stationnaire, on voit clairement une tendance ascendante.
acf(GNPts, lag.max=15)
decomp<-decompose(GNPts)
tendance<-decomp$trend
plot.ts(tendance)
plot.ts(GNPts-tendance)
GNPd1<-diff(GNPts)
GNPd1<-as.vector(GNPd1)
plot.ts(GNPd1)
# On peut remarquer qu'une première différenciation a suffit pour éliminer la tendance.
# Ceci confirme le caractère linéaire de la tendance obtenu dans la question précédente.
acf(GNPd1)
# Les autocorrélations empiriques ne sont plus significatives à partir de l'ordre 3,
# un MA(2) est un modèle candidat pour ajuster cette série.
pacf(GNPd1)
basicStats(log_returns)
log_returns <- na.omit(log_returns)
log_returns2 <- diff(log_returns)
log_returns2 <- na.omit(log_returns2)
acf(log_returns2)
pacf(log_returns2)
basicStats(log_returns)
log_returns <- na.omit(log_returns)
acf(log_returns)
pacf(log_returns)
knitr::opts_chunk$set(echo = TRUE)
if (!require("quantmod")) install.packages("quantmod")
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("fBasics")) install.packages("fBasics")
if (!require("tseries")) install.packages("tseries")
if (!require("urca")) install.packages("urca")
library(quantmod)
library(tidyverse)
library(fBasics)
library(tseries)
library(urca)
# Télécharger les données du CAC 40
cac40 <- getSymbols("^FCHI", src = "yahoo", from = "1990-01-01", to = "2023-12-31", auto.assign = FALSE)
# Extraire uniquement les prix de clôture
cac40_close <- na.omit(Cl(cac40))  # 'Cl()' extrait la colonne de clôture
#nous pouvons également considérer d'autres indicateurs tq le max sur la journée, le min...
colnames(cac40_close) <- "Close"
#Visualisation de la série
autoplot(cac40_close) +
ggtitle("Indice CAC 40 pour la période 1990-2023") +
xlab("Date") +
ylab("Clôture") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5))
# Vérifier s'il y a des valeurs manquantes dans la série
missing_values <- sum(is.na(cac40_close))
# Afficher le nombre de valeurs manquantes
print(paste("Nombre de valeurs manquantes :", missing_values))
# Si des valeurs manquantes existent, afficher leurs dates
if (missing_values > 0) {
missing_dates <- index(cac40_close)[is.na(cac40_close)]
print("Dates avec valeurs manquantes :")
print(missing_dates)
} else {
print("Aucune valeur manquante dans la série.")
}
basicStats(cac40_close)
#graphiquement
# Ajouter une tendance linéaire
autoplot(cac40_close) +
geom_smooth(method = "lm", se = FALSE, color = "red") +
ggtitle("Tendance linéaire de l'indice CAC 40") +
xlab("Date") +
ylab("Clôture") +
theme_minimal()
#avec le R**2
# Créer une variable temporelle
time <- as.numeric(index(cac40_close))
# Ajuster un modèle linéaire : Prix ~ Temps
lm_model <- lm(coredata(cac40_close) ~ time)
# Résumé du modèle
summary(lm_model)
# Convertir la série en périodicité mensuelle
cac40_monthly <- to.monthly(cac40_close, indexAt = "lastof", OHLC = FALSE)
# Visualisation des moyennes mensuelles
cac40_monthly_mean <- aggregate(cac40_monthly, as.yearmon, mean)
autoplot(cac40_monthly_mean) +
ggtitle("Moyennes mensuelles de l'indice CAC 40") +
xlab("Date") +
ylab("Moyenne mensuelle de clôture") +
theme_minimal()
# Détection visuelle avec boxplot
boxplot(coredata(cac40_close), main = "Détection des outliers",
ylab = "Prix de clôture", col = "lightblue")
# Repérer les outliers par quantile
q1 <- quantile(cac40_close, 0.25)
q3 <- quantile(cac40_close, 0.75)
iqr <- q3 - q1
outliers <- cac40_close[cac40_close < (q1 - 1.5 * iqr) | cac40_close > (q3 + 1.5 * iqr)]
print("Outliers détectés :")
print(outliers)
# Calcul des rendements logarithmiques
log_returns <- diff(log(cac40_close))
# Visualisation des rendements
autoplot(log_returns) +
ggtitle("Rendements logarithmiques du CAC 40") +
xlab("Date") +
ylab("Log-returns") +
theme_minimal()
# Statistiques descriptives des rendements
basicStats(log_returns)
# Histogramme des rendements
ggplot(data = data.frame(log_returns = coredata(log_returns)), aes(x = log_returns)) +
geom_histogram(bins = 50, fill = "lightblue", color = "black") +
ggtitle("Distribution des rendements logarithmiques") +
xlab("Log-returns") +
ylab("Fréquence") +
theme_minimal()
# Test ADF sur les rendements logarithmiques
adf_test <- adf.test(na.omit(log_returns))
# Afficher les résultats du test
print(adf_test)
# Test KPSS sur les rendements logarithmiques
kpss_test <- ur.kpss(na.omit(log_returns))
# Résumé des résultats
summary(kpss_test)
basicStats(log_returns)
log_returns <- na.omit(log_returns)
acf(log_returns)
pacf(log_returns)
